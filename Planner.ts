///<reference path="World.ts"/>
///<reference path="Interpreter.ts"/>
///<reference path="Graph.ts"/>


/**
* Planner module
*
* The goal of the Planner module is to take the interpetation(s)
* produced by the Interpreter module and to plan a sequence of actions
* for the robot to put the world into a state compatible with the
* user's command, i.e. to achieve what the user wanted.
*
* The planner should use your A* search implementation to find a plan.
*/
module Planner {

  //////////////////////////////////////////////////////////////////////
  // exported functions, classes and interfaces/types

  /**
  * Top-level driver for the Planner. Calls `planInterpretation` for each given interpretation generated by the Interpreter.
  * @param interpretations List of possible interpretations.
  * @param currentState The current state of the world.
  * @returns Augments Interpreter.InterpretationResult with a plan represented by a list of strings.
  */
  export function plan(interpretations : Interpreter.InterpretationResult[], currentState : WorldState) : PlannerResult[] {
    var errors : Error[] = [];
    var plans : PlannerResult[] = [];
    interpretations.forEach((interpretation) => {
      try {
        var result : PlannerResult = <PlannerResult>interpretation;
        result.plan = planInterpretation(result.interpretation, currentState);
        if (result.plan.length == 0) {
          result.plan.push("That is already true!");
        }
        plans.push(result);
      } catch(err) {
        errors.push(err);
      }
    });
    if (plans.length) {
      return plans;
    } else {
      // only throw the first error found
      throw errors[0];
    }
  }

  export interface PlannerResult extends Interpreter.InterpretationResult {
    plan : string[];
  }

  export function stringify(result : PlannerResult) : string {
    return result.plan.join(", ");
  }

  //     //////////////////////////////////////////////////////////////////////
  //     // private functions
  //
  //     /**
  //      * The core planner function. The code here is just a template;
  //      * you should rewrite this function entirely. In this template,
  //      * the code produces a dummy plan which is not connected to the
  //      * argument `interpretation`, but your version of the function
  //      * should be such that the resulting plan depends on
  //      * `interpretation`.
  //      *
  //      *
  //      * @param interpretation The logical interpretation of the user's desired goal. The plan needs to be such that by executing it, the world is put into a state that satisfies this goal.
  //      * @param state The current world state.
  //      * @returns Basically, a plan is a
  //      * stack of strings, which are either system utterances that
  //      * explain what the robot is doing (e.g. "Moving left") or actual
  //      * actions for the robot to perform, encoded as "l", "r", "p", or
  //      * "d". The code shows how to build a plan. Each step of the plan can
  //      * be added using the `push` method.
  //      */
  //     function planInterpretation(interpretation : Interpreter.DNFFormula, state : WorldState) : string[] {
  //         // This function returns a dummy plan involving a random stack
  //         do {
  //             var pickstack = Math.floor(Math.random() * state.stacks.length);
  //         } while (state.stacks[pickstack].length == 0);
  //         var plan : string[] = [];
  //
  //         // First move the arm to the leftmost nonempty stack
  //         if (pickstack < state.arm) {
  //             plan.push("Moving left");
  //             for (var i = state.arm; i > pickstack; i--) {
  //                 plan.push("l");
  //             }
  //         } else if (pickstack > state.arm) {
  //             plan.push("Moving right");
  //             for (var i = state.arm; i < pickstack; i++) {
  //                 plan.push("r");
  //             }
  //         }
  //
  //         // Then pick up the object
  //         var obj = state.stacks[pickstack][state.stacks[pickstack].length-1];
  //         plan.push("Picking up the " + state.objects[obj].form,
  //                   "p");
  //
  //         if (pickstack < state.stacks.length-1) {
  //             // Then move to the rightmost stack
  //             plan.push("Moving as far right as possible");
  //             for (var i = pickstack; i < state.stacks.length-1; i++) {
  //                 plan.push("r");
  //             }
  //
  //             // Then move back
  //             plan.push("Moving back");
  //             for (var i = state.stacks.length-1; i > pickstack; i--) {
  //                 plan.push("l");
  //             }
  //         }
  //
  //         // Finally put it down again
  //         plan.push("Dropping the " + state.objects[obj].form,
  //                   "d");
  //
  //         return plan;
  //     }
  //
  // }
  // ---------------- NEW CODE ----------------- NEW CODE --------------------- NEW CODE -------------------//

  //////////////////////////////////////////////////////////////////////
  // private functions

  /**
  * The core planner function. The code here is just a template;
  * you should rewrite this function entirely. In this template,
  * the code produces a dummy plan which is not connected to the
  * argument `interpretation`, but your version of the function
  * should be such that the resulting plan depends on
  * `interpretation`.
  *
  *
  * @param interpretation The logical interpretation of the user's desired goal. The plan needs to be such that by executing it, the world is put into a state that satisfies this goal.
  * @param state The current world state.
  * @returns Basically, a plan is a
  * stack of strings, which are either system utterances that
  * explain what the robot is doing (e.g. "Moving left") or actual
  * actions for the robot to perform, encoded as "l", "r", "p", or
  * "d". The code shows how to build a plan. Each step of the plan can
  * be added using the `push` method.
  */
  function planInterpretation(interpretation : Interpreter.DNFFormula, state : WorldState) : string[] {
    var plan : string[] = [];
    var graph : Graph<WorldState>;
    graph.outgoingEdges = getWorldStateEdges
    var start : WorldState = state;
    function goal(testState : WorldState) : boolean {
      for(var i=0; i< interpretation.length ; i++){
        for(var j=0; j< interpretation[i].length ; j++){
          //check if literal is fullfilled
          if(checkLiteral(interpretation[i][j],testState)){
            //if it's the last entry in the row, the DNF is fullfilled -> one (of perhaps many) goals is reached
            if(j === interpretation[i].length-1){
              return true
            }
          }
          //otherwise go to next row
          else{
            break
          }
        }
      }
      return false
    }
    function heuristic(testState : WorldState) : number {
      return 0
    }
    // max alocated time for a search in seconds
    var timeout : number = 5;

    var result : SearchResult<WorldState> = aStarSearch<WorldState>(graph,start,goal,heuristic,timeout);

    //result.path is the resulting series of worldStates we want to traverse to reach the goal
    var previousState : WorldState;
    var currentState : WorldState;
    for(var i=1;i<result.path.length;i++){
      previousState = result.path[i-1];
      currentState = result.path[i];
      //if the arm has moved right
      if(currentState.arm > previousState.arm){
        plan.push("r")
        continue
      }
      //if the arm has moved left
      if(currentState.arm < previousState.arm){
        plan.push("l")
        continue
      }
      //otherwise what is held has changed
      //if something was picked up
      if(currentState.holding.length > previousState.holding.length){
        plan.push("p")
        continue
      }
      //then something was dropped
      plan.push("d")
    }
    return plan;
  }

  function checkLiteral( literal : Interpreter.Literal, state : WorldState) : boolean {
    return false
  }

  /** Returns the out going edges from a world state node. These are the world states that occur if the
  arm either goes left, right, picks up, or drops an object (if these are possible actions). All edges have
  cost 1.
  */
  function getWorldStateEdges(state : WorldState) : Edge<WorldState>[] {
    var edges : Edge<WorldState>[];
    //if it's not all the way to the left, then the arm can move left
    if(state.arm !== 0){
      var newState : WorldState = deepCloneWorldState(state);
      newState.arm = newState.arm - 1;
      var newEdge : Edge<WorldState> = {from : state, cost : 1, to : newState}
      edges.push(newEdge)
    }
    //if it's not all the way to the right, then the arm can move right
    if(state.arm !== state.stacks.length-1){
      var newState : WorldState = deepCloneWorldState(state);
      newState.arm = newState.arm + 1;
      var newEdge : Edge<WorldState> = {from : state, cost : 1, to : newState}
      edges.push(newEdge)
    }
    //if the arm is holding an object
    if(state.holding.length){
      var grabbedObject = state.objects[state.holding];
      var topStackObject = state.objects[state.stacks[state.arm][state.stacks[state.arm].length-1]];
      //check that grabbedObject can be put ontop or inside topObject
      if(Interpreter.checkPhysicLaws(grabbedObject,topStackObject,"ontop") || Interpreter.checkPhysicLaws(grabbedObject,topStackObject,"inside") ){
        var newState : WorldState = deepCloneWorldState(state);
        newState.stacks[newState.arm].push(newState.holding);
        newState.holding = undefined;
        var newEdge : Edge<WorldState> = {from : state, cost : 1, to : newState}
        edges.push(newEdge)
      }
    }
    //if the arm is not holding anything, and there is an object below it, it can pick it up
    else {
      if(state.holding.length === 0 && (state.stacks[state.arm].length > 0)){
        var newState : WorldState = deepCloneWorldState(state);
        //remove top stack element and put it as held
        newState.holding = newState.stacks[newState.arm].pop();
        var newEdge : Edge<WorldState> = {from : state, cost : 1, to : newState}
        edges.push(newEdge)
      }
    }
    return edges

  }

  function deepCloneWorldState(state : WorldState) : WorldState{
    return state
  }

}
