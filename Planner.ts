///<reference path="World.ts"/>
///<reference path="Interpreter.ts"/>
///<reference path="Graph.ts"/>


/**
* Planner module
*
* The goal of the Planner module is to take the interpetation(s)
* produced by the Interpreter module and to plan a sequence of actions
* for the robot to put the world into a state compatible with the
* user's command, i.e. to achieve what the user wanted.
*
* The planner should use your A* search implementation to find a plan.
*/
module Planner {

  //////////////////////////////////////////////////////////////////////
  // exported functions, classes and interfaces/types

  /**
  * Top-level driver for the Planner. Calls `planInterpretation` for each given interpretation generated by the Interpreter.
  * @param interpretations List of possible interpretations.
  * @param currentState The current state of the world.
  * @returns Augments Interpreter.InterpretationResult with a plan represented by a list of strings.
  */
  export function plan(interpretations : Interpreter.InterpretationResult[], currentState : WorldState) : PlannerResult[] {
    var errors : Error[] = [];
    var plans : PlannerResult[] = [];
    interpretations.forEach((interpretation) => {
      try {
        var result : PlannerResult = <PlannerResult>interpretation;
        result.plan = planInterpretation(result.interpretation, currentState);
        if (result.plan.length == 0) {
          result.plan.push("That is already true!");
        }
        plans.push(result);
      } catch(err) {
        errors.push(err);
      }
    });
    if (plans.length) {
      return plans;
    } else {
      // only throw the first error found
      throw errors[0];
    }
  }

  export interface PlannerResult extends Interpreter.InterpretationResult {
    plan : string[];
  }

  export function stringify(result : PlannerResult) : string {
    return result.plan.join(", ");
  }
  //////////////////////////////////////////////////////////////////////
  // private functions

  /**
  * The core planner function.
  * @param interpretation The logical interpretation of the user's desired goal. The plan needs to be such that by executing it, the world is put into a state that satisfies this goal.
  * @param state The current world state.
  * @returns Basically, a plan is a
  * stack of strings, which are either system utterances that
  * explain what the robot is doing (e.g. "Moving left") or actual
  * actions for the robot to perform, encoded as "l", "r", "p", or "d".
  */
  function planInterpretation(interpretation : Interpreter.DNFFormula, state : WorldState) : string[] {
    var plan : string[] = [];
    //compare function defined seperatly in Graph.ts
    var graph : Graph<WorldState> = {outgoingEdges : getWorldStateEdges , compareNodes : null}
    var start : WorldState = state;

    /**
    The goal function tests if a world state is equal to the goal state,
     i.e. if the DNF-'interpretation' is fullfilled
    */
    function goal(testState : WorldState) : boolean {
      for(var i=0; i< interpretation.length ; i++){
        for(var j=0; j< interpretation[i].length ; j++){
          //check if literal is fullfilled
          if(checkLiteral(interpretation[i][j],testState)){
            //if it's the last entry in the row, the DNF is fullfilled -> one (of perhaps many) goals is reached
            if(j === interpretation[i].length-1){
              return true
            }
          }
          //otherwise go to next row
          else{
            break
          }
        }
      }
      return false
    }
    /**
    The heuristic given a world state. Is admissible.
    */
    function heuristic(testState : WorldState) : number {
      //assign a heuristic to each literal in the DNFFormula interpretation depending on how close it is to being true
      var h :number[][] = [];
      for (let i = 0; i < interpretation.length; i++) {
          h[i] = [];
          for (let j = 0; j < interpretation[i].length; j++) {
              h[i][j] = heuristicOfLiteral(testState,interpretation[i][j])
          }
      }
      //the final heuristic for the world state is the
      // i.e min( max( h of literals in DNF matrix) taken over rows ) taken over column
      //               1 2 4
      //  h of DNF =   5 3 9   =>   finalH = 4
      //               7 6 3
      var hMaxOfRows : number[]=[];
      for(var i =0; i< h.length ; i++){
        hMaxOfRows[i] = Math.max(...h[i])
      }
      return Math.min(...hMaxOfRows)
    }
    /** Gets an admissible heuristic for a signle literal depending on how
    close it is to being fullfilled in a world state
    */
    function heuristicOfLiteral(testState : WorldState, literal : Interpreter.Literal) : number{
      //if the literal is already fullfilled the heuristic is 0
      if(checkLiteral(literal,testState)){
        return 0
      }
      //else the heuristic is taken as a naive esitmate of the minimum cost
      //required to complete the moves required to satisfy the literal
      if(literal.polarity === true){
        //get coordinates of the first argument: ObjectA (there is always atleast 1)
        var objA : string = literal.args[0]
        var xObjA : number
        var yObjA : number
        //if the arm holds one of the objects, this is its x-Coordinate
        if(testState.holding === objA){
          xObjA = testState.arm
        }else{
          var coordsA : number[] = Interpreter.getCoords(objA,testState)
          xObjA = coordsA[0]
          yObjA = coordsA[1]
        }
        if(literal.relation === "holding"){
          var stackHeight = testState.stacks[xObjA].length
          var xArm : number = testState.arm
          // h = move arm to same column + pick + (minimum of 4 moves to remove another object from stack) * num of objects to move from stack
          return Math.abs(xObjA-xArm) + 1 + 4 * (stackHeight-yObjA-1)
        }
        //then there is a second argument aswell : ObjectB
        var objB :string = literal.args[1]
        var xObjB : number;
        var yObjB : number;
        if(testState.holding === objB){
          xObjB = testState.arm
        }else{
          var coordsB : number[] = Interpreter.getCoords(objB,testState)
          xObjB = coordsB[0]
          yObjB = coordsB[1]

        }
        if(literal.relation === "leftof"){
          //we punish A being to the right of B
          return Math.max(xObjA - xObjB,0)
        }
        if(literal.relation === "rightof"){
          //we punish A being to the left of B
          return Math.max(xObjB - xObjA,0)
        }
        if(literal.relation === "beside"){
          //we punish the x-distance between A and B being different from 1
          return Math.abs(Math.abs(xObjA-xObjB)-1)
        }
        if( literal.relation === "above"){
          //we punish the objects being far apart in x-distance, objA being deep down in stacks, and the arm far away
            var  depthOfA: number = testState.stacks[xObjA].length - yObjA - 1
            if(testState.holding === objA || testState.holding === objB){
            return Math.abs(xObjA-xObjB) + 3*depthOfA
          }else{
            return Math.abs(xObjA-xObjB) + 1 + 3*depthOfA + Math.min(Math.abs(testState.arm-xObjA),Math.abs(testState.arm-xObjB))
          }
        }
        if(literal.relation === "under"){
          //we punish the objects being far apart in x-distance, objB being deep down in stacks, and the arm far away
          var  depthOfB: number = testState.stacks[xObjB].length - yObjB - 1
          if(testState.holding === objA || testState.holding === objB){
            return Math.abs(xObjA-xObjB) + 3*depthOfB
          }else{
            return Math.abs(xObjA-xObjB) + 1 + 3*depthOfB + Math.min(Math.abs(testState.arm-xObjA),Math.abs(testState.arm-xObjB))
          }
        }
        if( literal.relation === "inside" || literal.relation === "ontop" ){
          //we punish the objects being far apart in x-distance, being deep down in stacks, and the arm far away
          if(testState.holding === objA || testState.holding === objB){
            return Math.abs(xObjA-xObjB)
          }else{
            var  depthOfA: number = testState.stacks[xObjA].length - yObjA - 1
            var  depthOfB: number = testState.stacks[xObjB].length - yObjB - 1
            return Math.abs(xObjA-xObjB) + 1 + 3*Math.max(depthOfA,depthOfB) + Math.min(Math.abs(testState.arm-xObjA),Math.abs(testState.arm-xObjB))
          }
        }
        throw "Unknown literal relation: "+literal.relation
      }else{
        //if literal.polarity === false, which it cannot become currently
        throw "literal.polarity===false: Not implemented. How did you get here?"
      }
    }
    // max allocated time for a search in seconds
    var timeout : number = 10;
    var result : SearchResult<WorldState> = aStarSearch<WorldState>(graph,start,goal,heuristic,timeout);
    //Result.path is the resulting series of worldStates we want to traverse to reach the goal.
    //We find the commands (l,r,p,d) by checking how these world states change in order from start to finish
    var previousState : WorldState;
    var currentState : WorldState;
    for(var i=0;i<result.path.length;i++){
      if(i===0){
        //the start node is not included in the result.path
        previousState = start;
      }
      else{
        previousState = result.path[i-1];
      }
      currentState = result.path[i];
      //if the arm has moved right
      if(currentState.arm > previousState.arm){
        plan.push("r")
        continue
      }
      //if the arm has moved left
      if(currentState.arm < previousState.arm){
        plan.push("l")
        continue
      }
      //otherwise what is held has changed
      //if something was picked up
      if(previousState.holding == null){
        plan.push("p")
        continue
      }
      //else something was dropped
      plan.push("d")
    }
    return plan;
  }
  /**
  checks whether a litteral is fullfilled
  */
  function checkLiteral( literal : Interpreter.Literal, state : WorldState) : boolean {
    var bool: boolean = false
    if(literal.relation ==="holding"){
      bool = (state.holding === literal.args[0]);
    }
    else{
      if(checkRelation(literal.args[0],literal.args[1],literal.relation,state)){
        bool = true;
      }
    }
    //return opposite if polarity is false
    if(literal.polarity === false){
      if(bool===false){
        return true
      }
      else{
        return false
      }
    }
    return bool
  }
  /**
  checks if two objects fullfill a relation in a given world state
  Similar to Interpreter.checkRelation() but takes different arguments
  */
  function checkRelation(objA : string, objB : string, relation : string, state : WorldState) : boolean{
    var coordinatesA = Interpreter.getCoords(objA,state);
    // special case: in relation to floor
    if(objB.substring(0,6) ==="floor-"){
      if(coordinatesA[0] === Number(objB.substring(6))){
        if(relation==="above" && coordinatesA[0] === Number(objB.substring(6,7))){
          return true
        }
        if(relation==="ontop" && coordinatesA[0] === Number(objB.substring(6,7))){
          if(coordinatesA[1] === 0){
            return true
          }
        }
      }
      return false
    }
    var coordinatesB : number[] = Interpreter.getCoords(objB,state)
    if(relation === "leftof"){
      if(coordinatesA[0]<coordinatesB[0]){
        return true
      }
    }
    else {if(relation === "rightof"){
      if(coordinatesA[0]>coordinatesB[0]){
        return true
      }
    }
    else {if(relation === "ontop"){
      if(state.objects[objB].form !== "box"){
        if(coordinatesA[0]===coordinatesB[0] && coordinatesA[1] === coordinatesB[1]+1){
          return true
        }
      }
    }
    else {if(relation === "inside"){
      if(state.objects[objB].form === "box"){
        if(coordinatesA[0]===coordinatesB[0] && coordinatesA[1] === coordinatesB[1]+1){
          return true
        }
      }
    }
    else {if(relation === "under"){
      if(coordinatesA[0]===coordinatesB[0] && coordinatesA[1]<coordinatesB[1]){
        return true
      }
    }
    else {if(relation === "beside"){
      if(Math.abs(coordinatesA[0]-coordinatesB[0])===1){
        return true
      }
    }
    else {if(relation === "above"){
      if(coordinatesA[0]===coordinatesB[0] && coordinatesA[1]>coordinatesB[1]){
        return true
      }
    }}}}}}}
    return false
  }

  /** Returns the outgoing edges from a world state node. These are the world states that occur if the
  arm either goes left, right, picks up, or drops an object (if these are possible actions). If a large
  object is moved/picked up the edge cost is 2 otherwise it is 1.
  */
  function getWorldStateEdges(state : WorldState) : Edge<WorldState>[] {
    var edges : Edge<WorldState>[] = [];
    // the cost of a move is 1 if the arm is holding nothing or a small object
    var movementsCost : number =1;
    // the cost is 2 for a large object
    if(state.holding != null && state.objects[state.holding].size === "large"){
      movementsCost = 2;
    }
    //if it's not all the way to the left, then the arm can move left
    if(state.arm !== 0){
      var newState1 : WorldState = deepCloneWorldState(state);
      newState1.arm = newState1.arm - 1;
      var newEdge1 : Edge<WorldState> = {from : state, cost : movementsCost, to : newState1}
      edges.push(newEdge1)
    }
    //if it's not all the way to the right, then the arm can move right
    if(state.arm !== state.stacks.length-1){
      var newState2 : WorldState = deepCloneWorldState(state);
      newState2.arm = newState2.arm + 1;
      var newEdge2 : Edge<WorldState> = {from : state, cost : movementsCost, to : newState2}
      edges.push(newEdge2)
    }
    //if the arm is holding an object
    if(state.holding != null){
      var grabbedObject = state.objects[state.holding];
      var topStackObject = state.objects[state.stacks[state.arm][state.stacks[state.arm].length-1]];
      //if there was no top object, set it to "floor"
      if(topStackObject == null){
        topStackObject = {form : "floor", color : null , size : null}
      }
      //check that grabbedObject can be put ontop or inside topObject
      if(Interpreter.checkPhysicLaws(grabbedObject,topStackObject,"ontop") || Interpreter.checkPhysicLaws(grabbedObject,topStackObject,"inside") ){
        var newState3 : WorldState = deepCloneWorldState(state);
        newState3.stacks[newState3.arm].push(newState3.holding);
        newState3.holding = null;
        var newEdge3 : Edge<WorldState> = {from : state, cost : movementsCost, to : newState3}
        edges.push(newEdge3)
      }
    }

    //if the arm is not holding anything, and there is an object below it, it can pick it up
    else {
      if(state.stacks[state.arm].length > 0){
        var newState4 : WorldState = deepCloneWorldState(state);
        //remove top stack element and put it as held
        newState4.holding = newState4.stacks[newState4.arm].pop();
        // picking up a large object has cost 2
        if(state.objects[newState4.holding].size === "large"){
          movementsCost = 2;
        }
        var newEdge4 : Edge<WorldState> = {from : state, cost : movementsCost, to : newState4}
        edges.push(newEdge4)
      }
    }
    return edges

  }
  /**
  Returns a deep clone of a world state (which can then be changed without affecting the original)
  */
  function deepCloneWorldState(state : WorldState) : WorldState{
    var stacksCopy : string[][] = [[]];
    for(var i =0;i<state.stacks.length;i++){
      stacksCopy[i] = [];
      for(var j =0;j<state.stacks[i].length;j++){
        stacksCopy[i][j] = state.stacks[i][j]
      }
    }
    var newState : WorldState = {
      arm : state.arm,
      holding : state.holding,
      stacks : stacksCopy,
      objects : state.objects,
      examples : state.examples
    }
    return newState
  }

}
