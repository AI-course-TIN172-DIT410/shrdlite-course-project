///<reference path="World.ts"/>
///<reference path="Interpreter.ts"/>
///<reference path="Graph.ts"/>


/**
* Planner module
*
* The goal of the Planner module is to take the interpetation(s)
* produced by the Interpreter module and to plan a sequence of actions
* for the robot to put the world into a state compatible with the
* user's command, i.e. to achieve what the user wanted.
*
* The planner should use your A* search implementation to find a plan.
*/
module Planner {

  //////////////////////////////////////////////////////////////////////
  // exported functions, classes and interfaces/types

  /**
  * Top-level driver for the Planner. Calls `planInterpretation` for each given interpretation generated by the Interpreter.
  * @param interpretations List of possible interpretations.
  * @param currentState The current state of the world.
  * @returns Augments Interpreter.InterpretationResult with a plan represented by a list of strings.
  */
  export function plan(interpretations : Interpreter.InterpretationResult[], currentState : WorldState) : PlannerResult[] {
    var errors : Error[] = [];
    var plans : PlannerResult[] = [];
    interpretations.forEach((interpretation) => {
      try {
        var result : PlannerResult = <PlannerResult>interpretation;
        result.plan = planInterpretation(result.interpretation, currentState);
        if (result.plan.length == 0) {
          result.plan.push("That is already true!");
        }
        plans.push(result);
      } catch(err) {
        errors.push(err);
      }
    });
    if (plans.length) {
      return plans;
    } else {
      // only throw the first error found
      throw errors[0];
    }
  }

  export interface PlannerResult extends Interpreter.InterpretationResult {
    plan : string[];
  }

  export function stringify(result : PlannerResult) : string {
    return result.plan.join(", ");
  }

  //     //////////////////////////////////////////////////////////////////////
  //     // private functions
  //
  //     /**
  //      * The core planner function. The code here is just a template;
  //      * you should rewrite this function entirely. In this template,
  //      * the code produces a dummy plan which is not connected to the
  //      * argument `interpretation`, but your version of the function
  //      * should be such that the resulting plan depends on
  //      * `interpretation`.
  //      *
  //      *
  //      * @param interpretation The logical interpretation of the user's desired goal. The plan needs to be such that by executing it, the world is put into a state that satisfies this goal.
  //      * @param state The current world state.
  //      * @returns Basically, a plan is a
  //      * stack of strings, which are either system utterances that
  //      * explain what the robot is doing (e.g. "Moving left") or actual
  //      * actions for the robot to perform, encoded as "l", "r", "p", or
  //      * "d". The code shows how to build a plan. Each step of the plan can
  //      * be added using the `push` method.
  //      */
  //     function planInterpretation(interpretation : Interpreter.DNFFormula, state : WorldState) : string[] {
  //         // This function returns a dummy plan involving a random stack
  //         do {
  //             var pickstack = Math.floor(Math.random() * state.stacks.length);
  //         } while (state.stacks[pickstack].length == 0);
  //         var plan : string[] = [];
  //
  //         // First move the arm to the leftmost nonempty stack
  //         if (pickstack < state.arm) {
  //             plan.push("Moving left");
  //             for (var i = state.arm; i > pickstack; i--) {
  //                 plan.push("l");
  //             }
  //         } else if (pickstack > state.arm) {
  //             plan.push("Moving right");
  //             for (var i = state.arm; i < pickstack; i++) {
  //                 plan.push("r");
  //             }
  //         }
  //
  //         // Then pick up the object
  //         var obj = state.stacks[pickstack][state.stacks[pickstack].length-1];
  //         plan.push("Picking up the " + state.objects[obj].form,
  //                   "p");
  //
  //         if (pickstack < state.stacks.length-1) {
  //             // Then move to the rightmost stack
  //             plan.push("Moving as far right as possible");
  //             for (var i = pickstack; i < state.stacks.length-1; i++) {
  //                 plan.push("r");
  //             }
  //
  //             // Then move back
  //             plan.push("Moving back");
  //             for (var i = state.stacks.length-1; i > pickstack; i--) {
  //                 plan.push("l");
  //             }
  //         }
  //
  //         // Finally put it down again
  //         plan.push("Dropping the " + state.objects[obj].form,
  //                   "d");
  //
  //         return plan;
  //     }
  //
  // }
  // ---------------- NEW CODE ----------------- NEW CODE --------------------- NEW CODE -------------------//

  //////////////////////////////////////////////////////////////////////
  // private functions

  /**
  * The core planner function. The code here is just a template;
  * you should rewrite this function entirely. In this template,
  * the code produces a dummy plan which is not connected to the
  * argument `interpretation`, but your version of the function
  * should be such that the resulting plan depends on
  * `interpretation`.
  *
  *
  * @param interpretation The logical interpretation of the user's desired goal. The plan needs to be such that by executing it, the world is put into a state that satisfies this goal.
  * @param state The current world state.
  * @returns Basically, a plan is a
  * stack of strings, which are either system utterances that
  * explain what the robot is doing (e.g. "Moving left") or actual
  * actions for the robot to perform, encoded as "l", "r", "p", or
  * "d". The code shows how to build a plan. Each step of the plan can
  * be added using the `push` method.
  */
  function planInterpretation(interpretation : Interpreter.DNFFormula, state : WorldState) : string[] {
    var plan : string[] = [];
    //compare function defined seperatly in Graph.ts
    var graph : Graph<WorldState> = {outgoingEdges : getWorldStateEdges , compareNodes : null}
    var start : WorldState = state;

    /**
    Tests if a world state is equal to the goal state, i.e. if the DNF-'interpretation' is fullfilled
    */
    function goal(testState : WorldState) : boolean {
      for(var i=0; i< interpretation.length ; i++){
        for(var j=0; j< interpretation[i].length ; j++){
          //check if literal is fullfilled
          if(checkLiteral(interpretation[i][j],testState)){
            //if it's the last entry in the row, the DNF is fullfilled -> one (of perhaps many) goals is reached
            if(j === interpretation[i].length-1){
              return true
            }
          }
          //otherwise go to next row
          else{
            break
          }
        }
      }
      return false
    }
    /**
    The heuristic given a world state
    */
    function heuristic(testState : WorldState) : number {
      return 0
    }
    // max alocated time for a search in seconds
    var timeout : number = 5;
    var result : SearchResult<WorldState> = aStarSearch<WorldState>(graph,start,goal,heuristic,timeout);
    //result.path is the resulting series of worldStates we want to traverse to reach the goal
    var previousState : WorldState;
    var currentState : WorldState;
    for(var i=0;i<result.path.length;i++){
      if(i===0){
        previousState = start;
      }
      else{
        previousState = result.path[i-1];
      }
      currentState = result.path[i];
      //if the arm has moved right
      if(currentState.arm > previousState.arm){
        plan.push("r")
        continue
      }
      //if the arm has moved left
      if(currentState.arm < previousState.arm){
        plan.push("l")
        continue
      }
      //otherwise what is held has changed
      //if something was picked up
      if(previousState.holding == null){
        plan.push("p")
        continue
      }
      //then something was dropped
      plan.push("d")
    }
    return plan;
  }
  /**
  checks whether a litteral is fullfilled
  */
  function checkLiteral( literal : Interpreter.Literal, state : WorldState) : boolean {
    var bool: boolean = false
    if(literal.relation ==="holding"){
      bool = (state.holding === literal.args[0]);
    }
    else{
      if(checkRelation(literal.args[0],literal.args[1],literal.relation,state)){
        bool = true;
      }
    }

    //return opposite if polarity is false
    if(literal.polarity === false){
      if(bool===false){
        return true
      }
      else{
        return false
      }
    }
    return bool
  }
  /**
  checks if two objects fullfill a relation in a given world state
  */
  function checkRelation(objA : string, objB : string, relation : string, state : WorldState) : boolean{
    var coordinatesA = Interpreter.getCoords(objA,state);
    // special case: in relation to floor
    if(objB.substring(0,6) ==="floor-"){
      if(coordinatesA[0] === Number(objB.substring(6))){
        if(relation==="above"){
          return true
        }
        if(relation==="ontop"){
          if(coordinatesA[1] === 0){
            return true
          }
        }
      }
      return false
    }
    var coordinatesB : number[] = Interpreter.getCoords(objB,state)
    if(relation === "leftof"){
      if(coordinatesA[0]<coordinatesB[0]){
        return true
      }
    }
    else {if(relation === "rightof"){
      if(coordinatesA[0]>coordinatesB[0]){
        return true
      }
    }
    else {if(relation === "ontop"){
      if(state.objects[objB].form !== "box"){
        if(coordinatesA[0]===coordinatesB[0] && coordinatesA[1] === coordinatesB[1]+1){
          return true
        }
      }
    }
    else {if(relation === "inside"){
      if(state.objects[objB].form === "box"){
        if(coordinatesA[0]===coordinatesB[0] && coordinatesA[1] === coordinatesB[1]+1){
          return true
        }
      }
    }
    else {if(relation === "under"){
      if(coordinatesA[0]===coordinatesB[0] && coordinatesA[1]<coordinatesB[1]){
        return true
      }
    }
    else {if(relation === "beside"){
      if(Math.abs(coordinatesA[0]-coordinatesB[0])===1){
        return true
      }
    }
    else {if(relation === "above"){
      if(coordinatesA[0]===coordinatesB[0] && coordinatesA[1]>coordinatesB[1]){
        return true
      }
    }}}}}}}
    return false
  }

  /** Returns the out going edges from a world state node. These are the world states that occur if the
  arm either goes left, right, picks up, or drops an object (if these are possible actions). All edges have
  cost 1.
  */
  function getWorldStateEdges(state : WorldState) : Edge<WorldState>[] {
    var edges : Edge<WorldState>[] = [];
    // the cost of a move is 1 if the arm is holding nothing or a small object
    var movementsCost : number =1;
    // the cost is 2 for a large object
    if(state.holding != null && state.objects[state.holding].size === "large"){
      movementsCost = 2;
    }
    //if it's not all the way to the left, then the arm can move left
    if(state.arm !== 0){
      var newState1 : WorldState = deepCloneWorldState(state);
      newState1.arm = newState1.arm - 1;
      var newEdge1 : Edge<WorldState> = {from : state, cost : movementsCost, to : newState1}
      edges.push(newEdge1)
    }
    //if it's not all the way to the right, then the arm can move right
    if(state.arm !== state.stacks.length-1){
      var newState2 : WorldState = deepCloneWorldState(state);
      newState2.arm = newState2.arm + 1;
      var newEdge2 : Edge<WorldState> = {from : state, cost : movementsCost, to : newState2}
      edges.push(newEdge2)
    }
    //if the arm is holding an object
    if(state.holding != null){
      var grabbedObject = state.objects[state.holding];
      var topStackObject = state.objects[state.stacks[state.arm][state.stacks[state.arm].length-1]];
      //if there was no top object, set it to "floor"
      if(topStackObject == null){
        topStackObject = {form : "floor", color : null , size : null}
      }
      //check that grabbedObject can be put ontop or inside topObject
      if(Interpreter.checkPhysicLaws(grabbedObject,topStackObject,"ontop") || Interpreter.checkPhysicLaws(grabbedObject,topStackObject,"inside") ){
        var newState3 : WorldState = deepCloneWorldState(state);
        newState3.stacks[newState3.arm].push(newState3.holding);
        newState3.holding = null;
        var newEdge3 : Edge<WorldState> = {from : state, cost : movementsCost, to : newState3}
        edges.push(newEdge3)
      }
    }

    //if the arm is not holding anything, and there is an object below it, it can pick it up
    else {
      if(state.stacks[state.arm].length > 0){
        var newState4 : WorldState = deepCloneWorldState(state);
        //remove top stack element and put it as held
        newState4.holding = newState4.stacks[newState4.arm].pop();
        // picking up a large object has cost 2
        if(state.objects[newState4.holding].size === "large"){
          movementsCost = 2;
        }
        var newEdge4 : Edge<WorldState> = {from : state, cost : movementsCost, to : newState4}
        edges.push(newEdge4)
      }
    }
    return edges

  }
  /**
  Returns a deep clone of a world state (which can then be changed without affecting the original)
  */
  function deepCloneWorldState(state : WorldState) : WorldState{
    var stacksCopy : string[][] = [[]];
    for(var i =0;i<state.stacks.length;i++){
      stacksCopy[i] = [];
      for(var j =0;j<state.stacks[i].length;j++){
        stacksCopy[i][j] = state.stacks[i][j]
      }
    }
    var newState : WorldState = {
      arm : state.arm,
      holding : state.holding,
      stacks : stacksCopy,
      objects : state.objects,
      examples : state.examples
    }
    return newState
  }

}
