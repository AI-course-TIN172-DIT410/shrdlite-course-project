
import {WorldState} from "./World";
import {Edge, Graph, SearchResult, aStarSearch} from "./Graph";
import {ShrdliteResult, DNFFormula, Literal} from "./Types";

/********************************************************************************
** Planner

The goal of the Planner module is to take the interpetation(s)
produced by the Interpreter module and to plan a sequence of 
actions for the robot to put the world into a state compatible 
with the user's command, i.e. to achieve what the user wanted.

You should implement the function 'makePlan'. 
The planner should use your A* search implementation to find a plan.
********************************************************************************/

//////////////////////////////////////////////////////////////////////
// exported functions, classes and interfaces/types

/* Top-level driver for the Planner. 
 * It calls `makePlan` for each given interpretation generated by the Interpreter. 
 * You don't have to change this function.
 *
 * @param interpretations: List of possible interpretations.
 * @param currentState: The current state of the world.
 * @returns: List of planner results, which are the interpretation results augmented with plans. 
 *           Each plan is represented by a list of strings.
 *           If there's a planning error, it returns a string with a description of the error.
 */

export function plan(interpretations : ShrdliteResult[], currentState : WorldState) : string | ShrdliteResult[] {
    var errors : string[] = [];
    var plans : ShrdliteResult[] = [];
    interpretations.forEach((result) => {
        var theplan : string | string[] = makePlan(result.interpretation, currentState);
        if (typeof(theplan) === "string") {
            errors.push(theplan);
        } else {
            result.plan = theplan;
            if (result.plan.length == 0) {
                result.plan.push("That is already true!");
            }
            plans.push(result);
        }
    });
    if (plans.length) {
        return plans;
    } else {
        // merge all errors into one
        return errors.join(" ; ");
    }
}

/* The core planner function. 
 * The code here is just a template; you should rewrite this function entirely. 
 * In this template, the code produces a dummy plan which is not connected 
 * to the argument 'interpretation'. Your version of the function should
 * analyse 'interpretation' in order to figure out what plan to return.
 *
 * @param interpretation: The logical interpretation of the user's desired goal. 
 * @param state: The current world state.
 * @returns: A plan, represented by a list of strings.
 *           If there's a planning error, it returns a string with a description of the error.
 */

function makePlan(interpretation : DNFFormula, state : WorldState) : string | string[] {
    // Select a random nonempty stack
    do {
        var pickstack = Math.floor(Math.random() * state.stacks.length);
    } while (state.stacks[pickstack].length == 0);
    var plan : string[] = [];

    // First move the arm to the selected stack
    if (pickstack < state.arm) {
        plan.push("Moving left");
        for (var i = state.arm; i > pickstack; i--) {
            plan.push("l");
        }
    } else if (pickstack > state.arm) {
        plan.push("Moving right");
        for (var i = state.arm; i < pickstack; i++) {
            plan.push("r");
        }
    }

    // Then pick up the topmost object in the selected stack
    var obj = state.stacks[pickstack][state.stacks[pickstack].length-1];
    plan.push("Picking up the " + state.objects[obj].form,
              "p");

    if (pickstack < state.stacks.length-1) {
        // Then move the arm to the rightmost stack
        plan.push("Moving as far right as possible");
        for (var i = pickstack; i < state.stacks.length-1; i++) {
            plan.push("r");
        }

        // Then move back to the original stack
        plan.push("Moving back");
        for (var i = state.stacks.length-1; i > pickstack; i--) {
            plan.push("l");
        }
    }

    // Finally put the object down again
    plan.push("Dropping the " + state.objects[obj].form,
              "d");

    return plan;
}

